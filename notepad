Learn HTML by Building a Cat Photo App:
The lower the number, the higher the importance, so h2 elements have less importance than h1 elements.
Example Code:
<h1>most important heading element</h1>
<h2>second most important heading element</h2>
<h3>third most important heading element</h3>
<h4>fourth most important heading element</h4>
<h5>fifth most important heading element</h5>
<h6>least important heading element</h6>

Only use one h1 element per page and place lower importance headings below higher importance headings.

The p element is used to create a paragraph of text on websites.

HTML5 has some elements that identify different content areas. These elements make your HTML easier to read and help with Search Engine Optimization (SEO) and accessibility.
The <main> element is used to represent the main content of the body of an HTML document. Content inside the main element should be unique to the document and should not be repeated in other parts of the document.

<img> elements have an opening tag without a closing tag. An element without a closing tag is known as a void element.

Add an anchor element that links to https://freecatphotoapp.com. At this point, the link wonâ€™t show up in the preview. A link's text must be placed between the opening and closing tags of an anchor (a) element.
The target attribute specifies where to open the linked document. target="\_blank" opens the linked document in a new tab or window.

Before adding any new content, you should make use of a section element to separate the present content from the future content.
The section element is used to define sections in a document, such as chapters, headers, footers, or any other sections of the document. It is a semantic element that helps with SEO and accessibility.

When you add a lower rank heading element to the page, it's implied that you're starting a new subsection.

The figure element represents self-contained content and will allow you to associate an image with a caption.
Nest the image you just added within a figure element.
A figure caption (figcaption) element is used to add a caption to describe the image contained within the figure element.
Here is an example of a figcaption element with the caption of A cute cat:

Example Code:
<figure>
  <img src="image.jpg" alt="A description of the image">
  <figcaption>A cute cat</figcaption>
</figure>

To place emphasis on a specific word or phrase, you can use the em element. by wrapping it in an emphasis <em> element.
The strong element is used to indicate that some text is of strong importance or urgent. by wrapping it in a <strong> element.

list items in an ordered list are numbered when displayed.

The form element is used to get information from a user like their name, email, and other details.
The action attribute indicates where form data should be sent.
Here is an example of a form element with an action attribute:

Example Code:
<form action="/submit-url"></form>

In the example, action="/submit-url" tells the browser that the form data should be sent to the path /submit-url.
The input element allows you several ways to collect data from a web form. Like img elements, input elements are a void element and do not need closing tags.
Nest an input element in the form element.
In order for a form's data to be accessed by the location specified in the action attribute, you must give the text field a name attribute and assign it a value to represent the data being submitted.
To prevent a user from submitting your form when required information is missing, you need to add the required attribute to an input element. There's no need to set a value to the required attribute. Instead, just add the word required to the input element, making sure there is space between it and other attributes.

Add a button element with the text Submit below the input element. The default behavior of clicking a form button without any attributes submits the form to the location specified in the form's action attribute.
However, relying on default behavior may cause confusion. Add the type attribute with the value submit to the button to make it clear that it is a submit button.

both input and button elements are inline elements, which don't appear on new lines.

you can use radio buttons for questions where you want only one answer out of multiple options.
Here is an example of a radio button with the option of cat:

Example Code
<input type="radio"> cat

label elements are used to help associate the text for an input element with the input element itself (especially for assistive technologies like screen readers).
Here is an example of a label element with a radio button:

Example Code
<label><input type="radio"> cat</label>

In the example, clicking on the word "cat" will also select the radio button.

To make it so selecting one radio button automatically deselects the other, both buttons must have a name attribute with the same value.
If you select the Indoor radio button and submit the form, the form data for the button is based on its name and value attributes. Since your radio buttons do not have a value attribute, the form data will include indoor-outdoor=on, which is not useful when you have multiple buttons.
Add a value attribute to both radio buttons. For convenience, set the button's value attribute to the same value as its id attribute.

The fieldset element is used to group related inputs and labels together in a web form. fieldset elements are block-level elements, meaning that they appear on a new line.
The legend element acts as a caption for the content in the fieldset element. It gives users context about what they should enter into that part of the form.

Forms commonly use checkboxes for questions that may have more than one answer. The input element with a type attribute set to checkbox creates a checkbox.

There's another way to associate an input element's text with the element itself. You can nest the text within a label element and add a for attribute with the same value as the input element's id attribute.

<input id="loving" type="checkbox">
<label for="loving">Loving</label>

Like radio buttons, form data for selected checkboxes are name/value attribute pairs. While the value attribute is optional, it's best practice to include it with any checkboxes or radio buttons on the page.

In order to make a checkbox checked or radio button selected by default, you need to add the checked attribute to it.
Here is an example of a radio button with the checked attribute:

Example Code
<input checked type="radio" name="meal" value="breakfast"> Breakfast

The footer element is used to define a footer for a document or section. A footer typically contains information about the author of the document, copyright data, links to terms of use, contact information, and more.

All page content elements that should be rendered to the page go inside the body element.
However, other important information goes inside the head element.
The head element is used to contain metadata about the document, such as its title, links to stylesheets, and scripts.
Metadata is information about the page that isn't displayed directly on the page.
The title element determines what browsers show in the title bar or tab for the page.

Notice that the entire contents of the page are nested within an html element. The html element is the root element of an HTML page and wraps all content on the page.
You can also specify the language of your page by adding the lang attribute to the html element.
Add the lang attribute with the value en to the opening html tag to specify that the language of the page is English.

All pages should begin with <!DOCTYPE html>. This special string is known as a declaration and ensures the browser tries to meet industry-wide specifications.

<!DOCTYPE html> tells browsers that the document is an HTML5 document which is the latest version of HTML.

You can set browser behavior by adding meta elements in the head. Here's an example:
Example Code

<meta attribute="value">
Inside the head element, nest a meta element with an attribute named charset. Set to the value to utf-8 which tells the browser how to encode characters for the page.
Note that the meta element is a void element.
You have completed the Cat Photo App project. Congratulations!


Learn Basic CSS by Building a Cafe Menu:
CSS is the language used to style an HTML document. It describes how HTML elements should be displayed on the screen.

The title is one of several elements that provide extra information not visible on the web page, but it is useful for search engines or how the page gets displayed.  

You can add style to an element by specifying it in the style element and setting a property for it like this:
Example Code
element {
property: value;
}

You can add the same group of styles to many elements by creating a list of selectors. Each selector is separated with commas like this:
Example Code
selector1, selector2 {
property: value;
}

Since there will be many more styles, it's best to put all the styles in a separate file and link to it.
Make sure to exclude the opening and closing style tags.

Now you need to link the styles.css file, so the styles will be applied again. Inside the head element, add a link element. Give it a rel attribute with the value of "stylesheet" and a href attribute with the value of "styles.css"

For the styling of the page to look similar on mobile as it does on a desktop or laptop, you need to add a meta element with a special content attribute.
Add the following within the head element:
Example Code

<meta name="viewport" content="width=device-width, initial-scale=1.0" />

The <div> element is used mainly for design layout purposes unlike the other content elements you have used so far.

The goal is to make the div not take up the entire width of the page. The CSS width property is perfect for this.

You can use the id selector to target a specific element with an id attribute. An id selector is defined by placing the hash symbol # directly in front of the element's id value. For example, if an element has the id of cat then you would target that element like this:
Example Code
#cat {
width: 250px;
}

Comments in CSS look like this:
Example Code
/_ comment here _/

Currently, the width of the #menu element is specified in pixels (px)
Change the width property's value to be 80%, to make it 80% the width of its parent element (body).

Next, you want to center the #menu horizontally. You can do this by setting its margin-left and margin-right properties to auto. Think of the margin as invisible space around an element.

However, it is more common to use a different selector to style your elements.
A class selector is defined by a name with a dot directly in front of it, like this:
Example Code
.class-name {
styles
}

<article> elements commonly contain multiple elements that have related information. In this case, it will contain a coffee flavor and a price for that flavor.

<p> elements are block-level elements, so they take up the entire width of their parent element.
To get them on the same line, you need to apply some styling to the <p> elements so they behave more like inline elements.

The p elements are nested in an article element with the class attribute of item. You can style all the p elements nested anywhere in elements with a class named item like this:
Example Code
.item p { }

inline-block elements only take up the width of their content. To spread them out, add a width property to the flavor and price class selectors that have a value of 50% each.
Well that did not work. Styling the p elements as inline-block and placing them on separate lines in the code creates an extra space to the right of the first p element, causing the second one to shift to the next line. One way to fix this is to make each p element's width a little less than 50%.

That worked, but there is still a little space on the right of the price.
You could keep trying various percentages for the widths. Instead, use the back space key on your keyboard to move the p element with the class price next to the p element with the class flavor so that they are on the same line in the editor. Make sure there is no space between the two elements.

If you make the width of the page preview smaller, you will notice at some point, some of the text on the left starts wrapping around to the next line. This is because the width of the p elements on the left side can only take up 50% of the space.
Since you know the prices on the right have significantly fewer characters, change the flavor class width value to be 75% and the price class width value to be 25%.

You can give your menu some space between the content and the sides with various padding properties.

The current width of the menu will always take up 80% of the body element's width. On a very wide screen, the coffee and dessert appear far apart from their prices.
Add a max-width property to the menu class with a value of 500px to prevent it from growing too wide.

You can change the font-family of text, to make it look different from the default font of your browser. Each browser has some common fonts available to it.
Change all the text in your body, by adding a font-family property with the value sans-serif. This is a fairly common font that is very readable.

It is a bit boring for all the text to have the same font-family. You can still have the majority of the text sans-serif and make just the h1 and h2 elements different using a different selector. use Impact font.

You can add a fallback value for the font-family by adding another font name separated by a comma. Fallbacks are used in instances where the initial is not found/available.

The typography of heading elements (e.g. h1, h2) is set by default values of users' browsers.
Add two new type selectors (h1 and h2). Use the font-size property for both, but use the value 40px for the h1 and 30px for the h2.

You can use an <hr> element to display a divider between sections of different content.

The default properties of an hr element will make it appear as a thin light grey line. You can change the height of the line by specifying a value for the height property.
Change the height of the hr element to be 3px.

Notice the grey color along the edges of the line. Those edges are known as borders. Each side of an element can have a different color or they can all be the same.

Notice how the thickness of the line looks bigger? The default value of a property named border-width is 1px for all edges of hr elements. By changing the border, the total height of the line is 5px (3px plus the top and bottom border width of 1px).
Change the height property of the hr to be 2px, so the total height of it becomes 4px.

To create a little more room around the menu, add 20px of space on the inside of the body element by using the padding property.

The default color of a link that has not yet been clicked on is typically blue. The default color of a link that has already been visited from a page is typically purple. To make the footer links the same color regardless if a link has been visited, use the value black for the color property.
You can change properties of a link when the link has actually been visited by using a pseudo-selector that looks like a:visited { propertyName: propertyValue; }.
You can change properties of a link when the mouse hovers over them by using a pseudo-selector that looks like a:hover { propertyName: propertyValue; }.
You change properties of a link when the link is actually being clicked by using a pseudo-selector that looks like a:active { propertyName: propertyValue; }.

The menu text CAMPER CAFE has a different space from the top than the address's space at the bottom of the menu. This is due to the browser having some default top margin for the h1 element.

<img> elements are "like" inline elements.
To make the image behave like heading elements (which are block-level), create an img type selector and use the value block for the display property and use the applicable margin-left and margin-right values to center it horizontally.

It would be nice if the vertical space between the h2 elements and their associated icons was smaller. The h2 elements have default top and bottom margin space, so you could change the bottom margin of the h2 elements to say 0 or another number.
There is an easier way, simply add a negative top margin to the img elements to pull them up from their current positions. Negative values are created using a - in front of the value. To complete this project, go ahead and use a negative top margin of 25px in the img type selector.


Learn CSS Colors by Building a Set of Colored Markers:
<title> element also displays the content of that title element in two more ways:
- in the title bar when the page is open
- in the browser tab for the page when you hover on it. Even if that tab is not active, once you hover on the tab, the title text is displayed.

charset attribute specifies the character encoding used by the document. utf-8 (Unicode Transformation Format â€“ 8-bit) is a character encoding standard used for electronic communication.

The background color was applied, but since the marker div element has no content in it, it doesn't have any height by default.

Your marker would look better if it was centered on the page. An easy way to do that is with the margin shorthand property.
In the last project, you set the margin area of elements separately with properties like margin-top and margin-left. The margin shorthand property makes it easy to set multiple margin areas at the same time.
To center your marker on the page, set its margin property to auto. This sets margin-top, margin-right, margin-bottom, and margin-left all to auto.

When the shorthand margin property has two values, it sets margin-top and margin-bottom to the first value, and margin-left and margin-right to the second value.

Multiple classes can be added to an element by listing them in the class attribute and separating them with a space. For example, the following adds both the animal and dog classes to a div element.
Example Code
<div class="animal dog">

There are two main color models: the additive RGB (red, green, blue) model used in electronic devices, and the subtractive CMYK (cyan, magenta, yellow, black) model used in print.
In this project, you'll work with the RGB model. This means that colors begin as black, and change as different levels of red, green, and blue are introduced. An easy way to see this is with the CSS rgb function.

A function is a piece of code that can take an input and perform a specific action. The CSS rgb function accepts values, or arguments, for red, green, and blue, and produces a color:
Example Code
rgb(red, green, blue);
Each red, green, and blue value is a number from 0 to 255. 0 means that there's 0% of that color, and is black. 255 means that there's 100% of that color.

the green color keyword is actually a darker shade, and is about halfway between black and the maximum value for green.
set the green value in the rgb function to 127 to lower its intensity.

use the shorthand padding property to add 10px of top and bottom padding, and set the left and right padding to 0. This works similarly to the shorthand margin property you used earlier.

In the additive RGB color model, primary colors are colors that, when combined, create pure white. But for this to happen, each color needs to be at its highest intensity.

Secondary colors are the colors you get when you combine primary colors. 
To create the first secondary color, yellow, update the rgb function in the .one CSS rule to combine pure red and pure green.

To create the next secondary color, cyan, update the rgb function in the .two CSS rule to combine pure green and pure blue.

To create the final secondary color, magenta, update the rgb function in the .three CSS rule to combine pure blue and pure red.

Tertiary colors are created by combining a primary with a nearby secondary color.
To create the tertiary color orange, update the rgb function in the .one CSS rule so that red is at the max value, and set green to 127.

Notice that, to create orange, you had to increase the intensity of red and decrease the intensity of the green rgb values. This is because orange is the combination of red and yellow.

To create the tertiary color spring green, combine cyan with green. Update the rgb function in the .two CSS rule so that green is at the max value, and set blue to 127.

And to create the tertiary color violet, combine magenta with blue. Update the rgb function in the .three CSS rule so that blue is at the max value, and set red to 127.

There are three more tertiary colors: chartreuse green (green + yellow), azure (blue + cyan), and rose (red + magenta).
To create chartreuse green, update the rgb function in the .one CSS rule so that red is at 127, and set green to the max value.
For azure, update the rgb function in the .two CSS rule so that green is at 127 and blue is at the max value.
And for rose, which is sometimes called bright pink, update the rgb function in the .three CSS rule so that blue is at 127 and red is at the max value.

A color wheel is a circle where similar colors, or hues, are near each other, and different ones are further apart. For example, pure red is between the hues rose and orange.
Two colors that are opposite from each other on the color wheel are called complementary colors. If two complementary colors are combined, they produce gray. But when they are placed side-by-side, these colors produce strong visual contrast and appear brighter.

It's better practice to choose one color as the dominant color, and use its complementary color as an accent to bring attention to certain content on the page.
First, in the h1 rule, use the rgb function to set its background-color to cyan.

Next, in the .one CSS rule, use the rgb function to set the background-color to black. And in the .two CSS rule, use the rgb function to set the background-color to red. (.three is already red.)
Notice how your eyes are naturally drawn to the red color in the center? When designing a site, you can use this effect to draw attention to important headings, buttons, or links.
There are several other important color combinations outside of complementary colors, but you'll learn those a bit later.

A very common way to apply color to an element with CSS is with hexadecimal or hex values. While hex values sound complicated, they're really just another form of RGB values.
Hex color values start with a # character and take six characters from 0-9 and A-F. The first pair of characters represent red, the second pair represent green, and the third pair represent blue. For example, #4B5320.
In the .green class selector, set the background-color property to a hex color code with the values 00 for red, FF for green, and 00 blue.

You may already be familiar with decimal, or base 10 values, which go from 0 - 9. Hexadecimal, or base 16 values, go from 0 - 9, then A - F:
Example Code
0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F
With hex colors, 00 is 0% of that color, and FF is 100%. So #00FF00 translates to 0% red, 100% green, and 0% blue, and is the same as rgb(0, 255, 0).
Lower the intensity of green by setting the green value of the hex color to 7F.

The HSL color model, or hue, saturation, and lightness, is another way to represent colors.
The CSS hsl function accepts 3 values: a number from 0 to 360 for hue, a percentage from 0 to 100 for saturation, and a percentage from 0 to 100 for lightness.
If you imagine a color wheel, the hue red is at 0 degrees, green is at 120 degrees, and blue is at 240 degrees.
Saturation is the intensity of a color from 0%, or gray, to 100% for pure color. You must add the percent sign % to the saturation and lightness values.
Lightness is how bright a color appears, from 0%, or complete black, to 100%, complete white, with 50% being neutral.
In the .blue CSS rule, use the hsl function to change the background-color property to pure blue. Set the hue to 240, the saturation to 100%, and the lightness to 50%.

You've learned a few ways to set flat colors in CSS, but you can also use a color transition, or gradient, on an element.
A gradient is when one color transitions into another. The CSS linear-gradient function lets you control the direction of the transition along a line, and which colors are used.
One thing to remember is that the linear-gradient function actually creates an image element, and is usually paired with the background property which can accept an image as a value.

The linear-gradient function is very flexible -- here is the basic syntax you'll use in this tutorial:
Example Code
linear-gradient(gradientDirection, color1, color2, ...);
gradientDirection is the direction of the line used for the transition. color1 and color2 are color arguments, which are the colors that will be used in the transition itself. These can be any type of color, including color keywords, hex, rgb, or hsl.
Now you'll apply a red-to-green gradient along a 90 degree line to the first marker.

the linear-gradient function needs at least two color arguments to work.
but it can accept many color arguments.

Color-stops allow you to fine-tune where colors are placed along the gradient line. They are a length unit like px or percentages that follow a color in the linear-gradient function.
For example, in this red-black gradient, the transition from red to black takes place at the 90% point along the gradient line, so red takes up most of the available space:
Example Code
linear-gradient(90deg, red 90%, black);

The shades on the top and bottom edges of the marker will be darker, while the one in the middle will be lighter, as if there's a light above it.

For the first color argument, which is currently pure red, update the rgb function so the value for red is 122, the value for green is 74, and the value for blue is 14.
Update the rgb function so the value for red is 245, the value of green is 62, and the value of blue is 113.
Update the rgb function so the value for red is 162, the value of green is 27, and the value of blue is 27.

For green marker, you'll use hex color codes for your gradient.
And for the first color argument, use a hex color code with the values 55 for red, 68 for green, and 0D for blue.
For the second color argument, use a hex color code with the values 71 for red, F5 for green, and 3E for blue.
In the same linear-gradient function, add a hex color code with the values 11 for red, 6C for green, and 31 for blue as the third color argument.

Use the linear-gradient function, and pass in the hsl function with the values 186 for hue, 76% for saturation, and 16% for lightness as the first color argument.
As the second color argument, pass in the hsl function with the values 223 for hue, 90% for saturation, and 60% for lightness.
And as the third color argument, pass in the hsl function with the values 240 for hue, 56% for saturation, and 42% for lightness.

Even without the color-stops, you might have noticed that the colors for the green marker transition at the same points as the red marker. The first color is at the start (0%), the second is in the middle (50%), and the last is at the end (100%) of the gradient line.
The linear-gradient function automatically calculates these values for you, and places colors evenly along the gradient line by default.

If no gradientDirection argument is provided to the linear-gradient function, it arranges colors from top to bottom, or along a 180 degree line, by default.

Opacity describes how opaque, or non-transparent, something is. For example, a solid wall is opaque, and no light can pass through. But a drinking glass is much more transparent, and you can see through the glass to the other side.
With the CSS opacity property, you can control how opaque or transparent an element is. With the value 0, or 0%, the element will be completely transparent, and at 1.0, or 100%, the element will be completely opaque like it is by default.

Another way to set the opacity for an element is with the alpha channel. Similar to the opacity property, the alpha channel controls how transparent or opaque a color is.
You're already familiar with using the rgb function to set colors. To add an alpha channel to an rgb color, use the rgba function instead.
The rgba function works just like the rgb function, but takes one more number from 0 to 1.0 for the alpha channel:
Example Code
rgba(redValue, greenValue, blueValue, alphaValue);
You can also use an alpha channel with hsl and hex colors. You will see how to do that soon.

Your sleeve is looking good, but it would look even better if it was positioned more toward the right side of the marker. One way to do that is to add another element before the sleeve to push it to the right.

It looks like your sleeve disappeared, but don't worry -- it's still there. What happened is that your new cap div is taking up the entire width of the marker, and is pushing the sleeve down to the next line.
This is because the default display property for div elements is block. So when two block elements are next to each other, they stack like actual blocks. For example, your marker elements are all stacked on top of each other.
To position two div elements on the same line, set their display properties to inline-block.

All HTML elements have borders, though they're usually set to none by default. With CSS, you can control all aspects of an element's border, and set the border on all sides, or just one side at a time. For a border to be visible, you need to set its width and style.
Borders have several styles to choose from. You can make your border a solid line, but you can also use a dashed or dotted line if you prefer. Solid border lines are probably the most common.
Your border should be visible now. If no color is set, black is used by default.
But to make your code more readable, it's better to set the border color explicitly.

you can change the border style to double solid borders.
For the border-left shorthand property, change the border style value from solid to double.

The box-shadow property lets you apply one or more shadows around an element. Here is basic syntax:
Example Code
box-shadow: offsetX offsetY color;
Here's how the offsetX and offsetY values work:
- both offsetX and offsetY accept number values in px and other CSS units
- a positive offsetX value moves the shadow right and a negative value moves it left
- a positive offsetY value moves the shadow down and a negative value moves it up
- if you want a value of zero (0) for any or both offsetX and offsetY, you don't need to add a unit. Every browser understands that zero means no change.
The height and width of the shadow is determined by the height and width of the element it's applied to. You can also use an optional spreadRadius value to spread out the reach of the shadow. More on that later.
But what if you wanted to position your shadow on the opposite side? You can do that by using negative values for offsetX and offsetY.

Notice that the edges of the shadow are sharp. This is because there is an optional blurRadius value for the box-shadow property:
Example Code
box-shadow: offsetX offsetY blurRadius color;
If a blurRadius value isn't included, it defaults to 0 and produces sharp edges. The higher the value of blurRadius, the greater the blurring effect is.

But what if you wanted to expand the shadow out further? You can do that with the optional spreadRadius value:
Example Code
box-shadow: offsetX offsetY blurRadius spreadRadius color;
Like blurRadius, spreadRadius defaults to 0 if it isn't included.
Practice by adding a 5 pixel shadow directly around the blue marker.

In the .red CSS rule, update the values for the box-shadow property so offsetX is 0,offsetY is 0, blurRadius is 20px, spreadRadius is 0, and color is red. Remember that you don't need to add units to a zero value.

Replace the named color with the rgba function. Use the values 83 for red, 14 for green, 14 for blue and 0.8 for the alpha channel.
Use the values 3B for red, 7E for green, 20 for blue, and CC for the alpha channel.
the hsla function. Use the values 223 for hue, 59% for saturation, 31% for lightness, and 0.8 for the alpha channel.


Learn HTML Forms by Building a Registration Form:
The vh unit stands for viewport height, and is equal to 1% of the height of the viewport. This makes it relative to the viewport height.

It is time to spruce the project up with some CSS. Begin by giving the body a width of 100%, and a height of 100vh.
And, get rid of the horizontal scroll-bar, by setting the body default margin added by some browsers to 0.

make the background easy on the eyes, by changing the body background-color to #1b1b32. Then, to see the text, change the color to #f5f6f7.

In form the method attribute specifies how to send form-data to the URL specified in the action attribute. The form-data can be sent via a GET request as URL parameters (with method="get") or via a POST request as data in the request body (with method="post").
Set the method attribute to send your form data via a POST request.

As the form will have three distinct sections, add three fieldset elements within the form element.

The rem unit stands for root em, and is relative to the font size of the html element.
As label elements are inline by default, they are all displayed side by side on the same line, making their text hard to read. To make them appear on separate lines, add display: block to the label element, and add a margin of 0.5rem 0, to separate them from each other.

Nest an input element within each label. Be sure to add each input after the label text, and include a space after the colon.

Specifying the type attribute of a form element is important for the browser to know what kind of data it should expect. If the type is not specified, the browser will default to text.
Give the first two input elements a type attribute of text, the third a type attribute of email, and the fourth a type attribute of password.
The email type only allows emails with a @ and a . in the domain. The password type obscures the input, and warns if the site does not use HTTPS.

The first input element with a type of submit is automatically set to submit its nearest parent form element.
To handle the form submission, after the last fieldset element add an input element with the type attribute set to submit and the value attribute set to Submit.

To make the form more interactive, add the required attribute to the input elements in the first fieldset.
Now, if you try to submit the form without filling in the required fields, you will see an error message.

Certain type attribute values come with built-in form validation. For example, type="email" requires that the value be a valid email address.
Add custom validation to the password input element, by adding a minlength attribute with a value of 8. Doing so prevents inputs of less than 8 characters being submitted.

With type="password" you can use the pattern attribute to define a regular expression that the password must match to be considered valid.
Add a pattern attribute to the password input element to require the input match: [a-z0-5]{8,}
The above is a regular expression which matches eight or more lowercase letters or the digits 0 to 5. Then, remove the minlength attribute, and try it out.

Within each corresponding label element, and immediately after the input radio element, add a space and add the following text:
Personal 
Business 

You only want one radio input to be selectable at a time. However, the form does not know the radio inputs are related.
To relate the radio inputs, give them the same name attribute with a value of account-type. Now, it is not possible to select both radio inputs at the same time.

Currently users can submit the form without checking the radio inputs. Although you previously used the required attribute to indicate that an input is required, it won't work in this case because adding required to both inputs will convey the wrong information to users.
To solve this, you can provide context of what is needed by adding a legend element with text Account type (required) before the label elements within the second fieldset. Then add the checked attribute to the Personal input to ensure the form is submitted with the required data in it.

Follow accessibility best practices by linking the input elements and the label elements in the second fieldset.
Use personal-account, and business-account as values for the respective id attributes.

Moving on to the final fieldset. What if you wanted to allow a user to upload a profile picture?
Well, the input type file allows just that. Add a label with the text Upload a profile picture: , and nest an input accepting a file upload.

Add another label after the first, with the text Input your age (years): . Then, nest an input with the type of number.
Next, add a min attribute to the input with a value of 13 because users under the age of 13 should not register. Also, users probably will not be over the age of 120; add a max attribute with a value of 120.
Now, if someone tries to submit the form with values outside of the range, a warning will appear, and the form will not submit. Give it a try.

Adding a dropdown to the form is easy with the select element. The select element is a container for a group of option elements, and the option element acts as a label for each dropdown option. Both elements require closing tags.
Start by adding a select element below the two label elements. Then nest 5 option 
elements within the select element.

Submitting the form with an option selected would not send a useful value to the server. As such, each option needs to be given a value attribute. Without which, the text content of the option will be submitted to the server.
Give the first option a value of "", and the subsequent option elements value attributes from 1 to 4.

The textarea element acts like an input element of type text, but comes with the added benefit of being able to receive multi-line text, and an initial number of text rows and columns.
Users will be able to register with a bio. Add a label with the text Provide a bio: at the end of the fieldset. Add a textarea element inside the label element. Note that the textarea requires a closing tag.
The textarea appears too small. To give it an initial size, you can add the rows and cols attributes.
Add an initial size of 3 rows and 30 columns.

To give Campers an idea of what to put in their bio, the placeholder attribute is used. The placeholder accepts a text value, which is displayed until the user starts typing.
Give the textarea a placeholder of I like coding on the beach....

With form submissions, it is useful, and good practice, to provide each submittable element with a name attribute. This attribute is used to identify the element in the form submission.
Except for the two radio inputs (which you have already named), give each submittable element a unique name attribute of your choosing.

Center the form element, by giving it a margin of 0 auto. Then, fix its size to a maximum width of 500px (500px se zaada nhi hoga form) 
and a minimum width of 300px (300px se kam nhi hoga form).
In between that range, allow it to have a 
width of 60vw (form ki width screen width ka 60% hogi, agar ye 60% 500px se zyada hoga to width 500px tak limited ho jayegi, aur agar 60% 300px se kam hoga to width 300px tak limited ho jayegi).

During development, it is useful to see the fieldset default borders. However, they make the content appear too separated.
Remove the border, and add 2rem of padding only to the top and bottom of each fieldset. Be sure to remove the padding from the left and right.

To give the fieldset elements a bit of separation, select them and give them a border-bottom of 3px solid #3b3b4f.

The border of the last fieldset element looks a little out of place. You can select the last element of a specific type using the last-of-type CSS pseudo-class, like this:
Example Code
p:last-of-type { }
That will select the last p element

It would be nicer to have the label text appear above the form elements.
Select all input, textarea, and select elements, and make them take up the full width of their parent elements.
Also, add 10px of margin to the top of the selected elements. Set the other margins to 0.

Select only the .inline elements, and give them width of unset. This will remove the earlier rule which set all the input elements to width: 100%.

If you look close enough, you will notice the .inline elements are too high on the line. To combat this, set the vertical-align property to middle.

To make the input and textarea elements blend in with the background theme, set their background-color to #0a0a23. Then, give them a 1px, solid border with a color of #0a0a23.
Currently, if you type in the input or textarea elements, you will not be able to see the text. Also, their height is too small to be easy to use.
Fix this, by setting the color to #ffffff, and setting their min-height to 2em.

You want the select element to remain with a white background, but now it is not getting the same min-height as the input and textarea elements.
Move the min-height property and value so that all three element types have the same min-height value, and the select element still has a white background.

To style the submit button, you can use an attribute selector, which selects an element based on the given attribute value. Here is an example:
Example Code
input[name="password"]
The above selects input elements with a name attribute value of password.

To make the submit button appear more distinct, give it a background-color of #3b3b4f, and a border-color of white.

Most browsers inject their own default CSS properties and values for different elements. If you look closely, you might be able to notice the file input is smaller than the other text input elements. By default, a padding of 1px 2px is given to input elements you can type in.
Using another attribute selector, style the input with a type of file to be the same padding as the other input elements.

Lastly change the text color of the terms and conditions link element to #dfdfe2 by adding a new selector in the CSS.
Well done! You have completed the final part of the Registration Form practice project.


Learn the CSS Box Model by Building a Rothko Painting:
In the CSS box model, every HTML element is treated as a box with four areas.

Imagine you receive a box from your favorite online retailer -- the content is the item in the box, or in our case, a header, paragraph, or image element.
The content is surrounded by a space called padding, similar to how bubble wrap separates an item from the box around it.
Think of the border like the cardboard box your item was shipped in.
Margin is the area outside of the box, and can be used to control the space between other boxes or elements.

Even though your <div> has no text, it's still treated as a box with content. Write a CSS rule that uses the .canvas class selector and set its width to 500 pixels.
Change the background-color of the canvas to #4d0f00.

Every painting needs a frame.
Wrap the .canvas element in another div. Give that div the frame class.

The frame is much too wide.
In .frame, set its width to 500 pixels.

Use padding to adjust the spacing within an element.
In .frame, use the padding shorthand property to increase the space between the .frame and .canvas elements by 50px. The shorthand will increase space in the top, bottom, left, and right of the element's border and canvas within.

Write a new rule that targets .one and set its width to 425 pixels.  height for .one to 150 pixels.
Set the background-color of .one to #efb762.

Now .one is centered horizontally, but its top margin is pushing past the canvas and onto the frame's border, shifting the entire canvas down 20 pixels.
Add padding of 1px to the .canvas element to give the .one element something solid to push off of.
Replace the padding property with overflow set to hidden - changing the canvas back to its original dimensions.

Create a new CSS rule using the .two selector and set its width to 475 pixels.
height 200px
background-color of the .two element to #8f0401.

You don't always have to use pixels when sizing an element.
Create a new rule, .three, and set its width to 91%.
height 28%
background-color of .three to #b20403.

Use the filter property to blur the painting by 2px in the .canvas element.
Here's an example of a rule that add a 3px blur:

Example Code
p {
  filter: blur(3px);
}

targets both .one and .two and increase their blur effect by 1 pixel.
Increase the blur of .three by 2 pixels.

The rectangles are too small and their edges don't have the soft quality of a painting.
Increase the area and soften the edges of .one by setting its box-shadow to 0 0 3px 3px #efb762.

same for two but change color #8f0401.

.three with the values 0 0 5px 5px #b20403.

Round each corner of the .one element by 9 pixels, using the border-radius property.
on the .two selector, to set its top-left radius and bottom-right radius to 8px, and top-right radius and bottom-left radius to 10px.
The border-radius property accepts up to four values to round the top-left, top-right, bottom-right, and bottom-left corners.
Round the top-left corner of .three by 30 pixels, the top-right by 25 pixels, the bottom-right by 60 pixels, and bottom-left by 12 pixels.

Rotate each rectangle to give them more of an imperfect, hand-painted look.
Use the transform property on the .one selector to rotate it counter clockwise by 0.6 degrees.
.two element clockwise by 0.4 degrees.
.three element counter clockwise by 0.2 degrees.


